## Google Agenet2Agent (A2A Protocol)

### Why A2A?

As agents become more specialized, tasks like planning an international trip require coordinating multiple agents (e.g., for flights, hotels, tours). Without a common protocol, this creates significant engineering hurdles for several key reasons:

- Lack of Dynamic Discovery: A client agent cannot dynamically find the best service for a job or discover alternatives if a primary agent fails, as connections are often hardcoded.

- Brittle, Custom Integrations: Each connection requires custom code, leading to a complex architecture that is difficult to scale and maintain.

- Poor Support for Agentic Workflows: Traditional request-response APIs are ill-suited for the long-running, asynchronous, and multi-turn conversations that are common in agent interactions.

### Key Components

![Key Components](assets/a2a-actors.png)

#### Core Actors

The protocol defines three distinct roles in any interaction:

- User: The end-user, who can be a human or another automated service, that initiates the goal or request.
- A2A Client (Client Agent): An application or agent that acts on the user's behalf. It is responsible for initiating communication and sending tasks to other agents.
- A2A Server (Remote Agent): An agent that exposes an A2A-compliant HTTP endpoint. It receives, processes, and responds to tasks sent by clients.

#### Communication Objects

These are the standardized data structures that agents exchange:

- Agent Card: A public JSON file that serves as an agent's profile. It's used for discovery and details the agent's identity, its specific skills, its endpoint URL, and its security/authentication requirements.
- Task: The central, stateful object representing an entire job or conversation. It is identified by a unique ID and has a defined lifecycle (submitted, working, input-required, completed, etc.), which allows for tracking long-running, multi-step processes.
- Message: Represents a single turn of communication within a task. It has a role (either "user" or "agent") to structure the dialogue and contains one or more Part objects.
- Part: The fundamental unit of content within a Message or Artifact. The protocol defines specific types to handle multi-modal data: TextPart for plain text, FilePart for binary data (like images or PDFs), and DataPart for structured JSON (like forms).
- Artifact: Represents a final, immutable output generated by the remote agent as a result of a task. This could be a generated file, a spreadsheet, or structured data, and is distinct from the conversational messages exchanged during processing.

#### Key Interaction Mechanisms

A2A supports three flexible models for communication to suit different needs:

- Request/Response (Polling): The standard model where a client sends a request. For long-running tasks, the server can immediately acknowledge the task, and the client can periodically poll a tasks/get endpoint to check the status until it's complete.
- Streaming (Server-Sent Events - SSE): For real-time updates, a client can subscribe to a task. This keeps a connection open, allowing the server to push status updates or incremental results to the client as they happen, eliminating the need for polling.
- Push Notifications (Webhooks): For very long-running or offline tasks where a persistent connection isn't feasible, a client can provide a webhook URL. The server can then send an HTTP POST request to this URL to notify the client of any important task updates.